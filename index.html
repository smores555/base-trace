<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Base Bid — v26 UI Skin + Vacancy Ledger Logic</title>
<style>
  :root{
    --bg:#071222; --fg:#eaf2ff; --muted:#a9b6d4; --card:#0b162a; --border:#1e2a44;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    --pill:#0f223f; --accent:#6aa6ff;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;}
  .wrap{max-width:1200px;margin:28px auto;padding:0 16px;}
  .banner{padding:10px 14px;border:1px solid var(--border);background:#0c1930;border-radius:12px;margin-bottom:16px;display:flex;justify-content:space-between;align-items:center;gap:10px}
  .pill{background:var(--pill);padding:4px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px}
  .grid{display:grid;grid-template-columns:340px 1fr;gap:14px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
  h1{font-size:16px;margin:0 0 8px 0}
  h2{font-size:14px;margin:10px 0 6px 0;color:var(--muted)}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid var(--border);padding:6px 8px;text-align:left}
  input,select,textarea{background:#0b1426;color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:8px}
  button{background:#17325d;border:1px solid var(--border);color:var(--fg);padding:8px 12px;border-radius:10px;cursor:pointer}
  button.secondary{background:#0f223f}
  .mono{font-family:var(--mono)}
  .muted{color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .cols{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .box{border:1px solid var(--border);border-radius:10px;padding:8px;background:#0e1830}
  .list{max-height:360px;overflow:auto;white-space:pre-wrap}
  .small{font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="banner">
    <div><b>Base Bid — v26 UI</b> <span class="pill">Vacancy Ledger Engine</span></div>
    <div class="row small">
      <span id="status" class="mono muted">Ready.</span>
    </div>
  </div>

  <div class="grid">
    <!-- LEFT: Controls -->
    <div class="card">
      <h1>Controls</h1>
      <div class="row">
        <button id="btnRun">Run</button>
        <button class="secondary" id="btnExport">Export Movers CSV</button>
        <button class="secondary" id="btnClear">Clear</button>
      </div>

      <h2>Vacancies (Δ adds, CA only)</h2>
      <div class="small muted" style="margin-bottom:6px">Edit posted adds per base for Captains; saved in-memory for this run.</div>
      <table id="capTable">
        <thead><tr><th>Base</th><th>Seat</th><th>Δ</th></tr></thead>
        <tbody></tbody>
      </table>

      <h2>Pilot Trace</h2>
      <div class="row">
        <input id="traceQuery" placeholder="SEN or NAME e.g. 1010 or SMITH, JASON" style="min-width:260px">
        <label class="muted"><input type="checkbox" id="traceEnabled"> Enable trace</label>
        <button class="secondary" id="btnTraceClear">Clear</button>
      </div>
      <pre id="traceLog" class="mono box list" style="max-height:180px"></pre>
    </div>

    <!-- RIGHT: Results -->
    <div class="cols">
      <div class="card">
        <h1>Movers & Upgrades (Seniority order)</h1>
        <pre id="movers" class="mono box list" style="max-height:420px"></pre>
      </div>
      <div class="card">
        <h1>Vacancy Ledger</h1>
        <pre id="vacLedger" class="mono box list" style="max-height:420px"></pre>
      </div>
      <div class="card" style="grid-column:1 / span 2">
        <h1>Detailed Ledger</h1>
        <pre id="ledger" class="mono box list" style="max-height:320px"></pre>
      </div>
    </div>
  </div>
</div>

<script>
// ===== State
const state = { running:false, pass:0, moves:[] };

// ===== Utils
function key(base, seat){ return `${String(base).toUpperCase()}|${String(seat).toUpperCase()}`; }
function qNorm(s){ return String(s||'').trim().toUpperCase(); }
function setStatus(s){ const el=document.getElementById('status'); if(el) el.textContent=s; }
function logTrace(msg){
  const box = document.getElementById('traceLog');
  if (box){ box.textContent += (box.textContent ? '\\n' : '') + msg; box.scrollTop = box.scrollHeight; }
  try { console.log(msg); } catch(e){}
}
function pilotMatchesTrace(p){
  const on = document.getElementById('traceEnabled').checked;
  if(!on) return false;
  const q = qNorm(document.getElementById('traceQuery').value);
  if(!q) return false;
  if (q === String(p.sen).toUpperCase()) return true;
  if (q === qNorm(p.name)) return true;
  return false;
}
function csvEscape(x){ return `"${String(x).replace(/"/g,'""')}"`; }

// ===== Data
let roster=[], preferences={}, capacities=[];

// ===== Vacancy Ledger
const Vac = new Map(); // "BASE|SEAT" -> int
function vacAmt(k){ return Vac.get(k)||0; }
function vacInc(k, n=1){ Vac.set(k, (Vac.get(k)||0) + n); }
function vacDec(k, n=1){ Vac.set(k, Math.max(0, (Vac.get(k)||0) - n)); }

// Live occupants
const Occupants = new Map();
function seedOccupants(){
  Occupants.clear();
  for (const p of roster){
    const k = key(p.current.base, p.current.seat);
    if (!Occupants.has(k)) Occupants.set(k, new Set());
    Occupants.get(k).add(p.sen);
  }
}
function moveOccupant(p, fromK, toK){
  if (fromK){ const s = Occupants.get(fromK); if (s) s.delete(p.sen); }
  if (!Occupants.has(toK)) Occupants.set(toK, new Set());
  Occupants.get(toK).add(p.sen);
}

// Preferences
function prefEntryFor(p){
  if (p && p.id && preferences[p.id]) return preferences[p.id];
  const senStr = String(p?.sen ?? '');
  if (senStr && preferences[senStr]) return preferences[senStr];
  const pilKey = 'pil' + senStr;
  if (preferences[pilKey]) return preferences[pilKey];
  return null;
}
function sameChoice(b1,s1,b2,s2){
  return String(b1).toUpperCase()===String(b2).toUpperCase() &&
         String(s1).toUpperCase()===String(s2).toUpperCase();
}
function rankPrefs(p){
  const pe = prefEntryFor(p);
  const list = (pe?.preferences || []).slice().filter(x => x && x.stay !== true);
  list.sort((a,b)=> (a.order||0) - (b.order||0));
  let stopIdx = -1;
  for (let i=0;i<list.length;i++){
    const w = list[i];
    if (sameChoice(w.base, w.seat, p.current.base, p.current.seat)){ stopIdx = i; break; }
  }
  if (stopIdx>=0) return list.slice(0, stopIdx+1);
  return list;
}
function bplSatisfied(p,w,toK){ return {ok:true, reason:''}; } // stub

// ===== Render
function renderCapTable(){
  const tb = document.querySelector('#capTable tbody'); if(!tb) return;
  tb.innerHTML = '';
  // List CA seats only
  const ca = capacities.filter(c => String(c.seat||'').toUpperCase()==='CA');
  const seen = new Set();
  for (const c of ca){
    const k = key(c.base, c.seat);
    if (seen.has(k)) continue; seen.add(k);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class="mono">${c.base}</td><td class="mono">${c.seat}</td>
      <td><input type="number" value="${Number(c.delta||0)}" data-base="${c.base}" data-seat="${c.seat}"/></td>`;
    tb.appendChild(tr);
  }
  tb.querySelectorAll('input').forEach(inp => {
    inp.addEventListener('change', ()=>{
      const b = inp.getAttribute('data-base'), s = inp.getAttribute('data-seat');
      for (const c of capacities){
        if (String(c.base).toUpperCase()===String(b).toUpperCase() &&
            String(c.seat).toUpperCase()===String(s).toUpperCase()){
          c.delta = Number(inp.value||0);
        }
      }
    });
  });
}
function renderVacLedger(){
  const out = document.getElementById('vacLedger'); if(!out) return;
  const lines = [];
  for (const [k,v] of Array.from(Vac.entries()).sort()){
    const [b,s] = k.split('|');
    if (s!=='CA') continue;
    lines.push(`${b} ${s}: Vac=${v}`);
  }
  out.textContent = lines.join('\n');
}
function renderMoversBySeniority(ledger){
  const out = document.getElementById('movers'); if(!out) return;
  const rows = ledger.slice().sort((a,b)=> (a.sen||1e9)-(b.sen||1e9)).map(l => {
    const [fb,fs] = (l.from||'|').split('|'); const [tb,ts] = (l.to||'|').split('|');
    return `${l.sen} ${l.name} — ${fb} ${fs} → ${tb} ${ts}`;
  });
  out.textContent = rows.join('\n');
}
function renderLedger(ledger){
  const out = document.getElementById('ledger'); if(!out) return;
  out.textContent = ledger.map(l => `${l.sen} ${l.name} — ${l.from} → ${l.to}`).join('\n');
}
function exportCSV(ledger){
  const header = ['sen','name','from_base','from_seat','to_base','to_seat'];
  const rows = ledger.map(l=>{
    const [fb,fs] = (l.from||'|').split('|'); const [tb,ts] = (l.to||'|').split('|');
    return [l.sen,l.name,fb,fs,tb,ts].map(csvEscape).join(',');
  });
  const csv = [header.join(','), ...rows].join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'movers.csv'; a.click();
  URL.revokeObjectURL(url);
}

// ===== IO
async function loadJSON(){
  const load = (p)=> fetch(p).then(r=>{ if(!r.ok) throw new Error(`${p}: ${r.status}`); return r.json(); });
  [roster, preferences, capacities] = await Promise.all([load('roster.json'), load('preferences.json'), load('capacities.json')]);
}

// ===== Engine helpers
function seedVacFromCap(){
  Vac.clear();
  // init
  for (const c of capacities){ Vac.set(key(c.base,c.seat), 0); }
  // seed CA adds
  for (const c of capacities){
    if (String(c.seat||'').toUpperCase()!=='CA') continue;
    const d = Number(c.delta||0);
    if (d>0) vacInc(key(c.base,c.seat), d);
  }
  renderVacLedger();
}
function award(p, fromK, toK, ledger, tag){
  ledger.push({sen:p.sen, name:p.name, from:fromK, to:toK, tag});
  const [tb,ts] = toK.split('|');
  p.current = {...p.current, base:tb, seat:ts};
  moveOccupant(p, fromK, toK);
  renderLedger(ledger);
  renderMoversBySeniority(ledger);
  state.moves.push({sen:p.sen, from:fromK, to:toK});
}

// ===== Run
async function run(){
  try{
    state.running=true; state.pass=1; state.moves.length=0;
    setStatus('Running…');
    await loadJSON();
    renderCapTable();
    seedOccupants();
    seedVacFromCap();

    const sorted = roster.slice().sort((a,b)=> (a.sen||1e9)-(b.sen||1e9));
    const ledger = [];

    // Vacancy-first (CA posted adds), FO→CA allowed, consume Vac[to], DON'T add Vac[from]
    let changed = true;
    while (changed){
      changed = false;
      for (const p of sorted){
        const prefsCA = rankPrefs(p).filter(w => String(w.seat||'').toUpperCase()==='CA');
        if (!prefsCA.length) continue;
        const fromK = key(p.current.base, p.current.seat);
        let got = false;
        for (const w of prefsCA){
          const toK = key(w.base, 'CA');
          const have = vacAmt(toK);
          if (pilotMatchesTrace(p)) logTrace(`[PASS ${state.pass}] Considering ${p.sen} ${p.name} for ${w.base} CA (Vac=${have})`);
          if (have<=0){ if (pilotMatchesTrace(p)) logTrace('  REJECT: no vacancy — incumbency protection'); continue; }
          const bpl = bplSatisfied(p,w,toK); if (!bpl.ok){ if (pilotMatchesTrace(p)) logTrace(`  REJECT: BPL fail (${bpl.reason})`); continue; }
          award(p, fromK, toK, ledger, 'posted-add');
          vacDec(toK,1);
          if (pilotMatchesTrace(p)) logTrace(`  AWARD: ${fromK} → ${toK} (posted-add)`);
          state.pass++; changed=true; got=true;
          renderVacLedger();
          break;
        }
        if (got) break; // restart from top
      }
    }

    // Cascade: restart from top after ANY award; multi-hop; create real vacancies where people leave
    let movedSweep = true;
    while (movedSweep){
      movedSweep = false;
      for (const p of sorted){
        const fromK = key(p.current.base, p.current.seat);
        const prefs = rankPrefs(p);
        let got = false;
        for (const w of prefs){
          if (sameChoice(w.base,w.seat,p.current.base,p.current.seat)){
            if (pilotMatchesTrace(p)) { logTrace(`[PASS ${state.pass}] HIT STAY: ${w.base} ${w.seat}`); logTrace('  STOP-AFTER-HOME rule: later prefs ignored'); }
            break;
          }
          const toK = key(w.base, w.seat);
          const have = vacAmt(toK);
          if (pilotMatchesTrace(p)) logTrace(`[PASS ${state.pass}] Pref ${w.base} ${w.seat} (Vac=${have}) for ${p.sen} ${p.name}`);
          if (have<=0){ if (pilotMatchesTrace(p)) logTrace('  REJECT: no vacancy — incumbency protection'); continue; }
          const bpl = bplSatisfied(p,w,toK); if (!bpl.ok){ if (pilotMatchesTrace(p)) logTrace(`  REJECT: BPL fail (${bpl.reason})`); continue; }
          award(p, fromK, toK, ledger, 'cascade');
          vacDec(toK,1); vacInc(fromK,1);
          if (pilotMatchesTrace(p)) logTrace(`  AWARD: ${fromK} → ${toK} (cascade)`);
          state.pass++; movedSweep=true; got=true;
          renderVacLedger();
          break;
        }
        if (movedSweep) break; // restart from top
      }
    }

    setStatus(`Done. Passes=${state.pass} Moves=${state.moves.length}`);
  }catch(e){
    console.error(e);
    setStatus('Error: '+e.message);
  }finally{
    state.running=false;
  }
}

// ===== Boot
function boot(){
  document.getElementById('btnRun').onclick = run;
  document.getElementById('btnExport').onclick = ()=> exportCSV(state.moves.map(m => ({...m, name: (roster.find(r=>r.sen===m.sen)||{}).name })));
  document.getElementById('btnClear').onclick = ()=>{ document.getElementById('movers').textContent=''; document.getElementById('ledger').textContent=''; document.getElementById('traceLog').textContent=''; };
  document.getElementById('btnTraceClear').onclick = ()=>{ document.getElementById('traceLog').textContent=''; };
  setStatus('Ready. Place roster.json, preferences.json, capacities.json alongside this file.');
}
boot();
</script>
</body>
</html>
