
<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>BUILD‑V12 (Self‑Contained) — Vacancy‑first → Cascade + Pilot Trace</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
  :root { --bg:#091426; --fg:#eaf2ff; --muted:#9fb3d1; --accent:#5aa2ff; --border:#1e2b46; }
  body { background:var(--bg); color:var(--fg); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, 'Helvetica Neue', Arial; margin:20px; }
  h1,h2,h3 { margin:8px 0; }
  .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  button { background:#0f223e; color:var(--fg); border:1px solid var(--border); border-radius:10px; padding:8px 12px; cursor:pointer; }
  button.secondary { background:#0b1b33; }
  .card { border:1px solid var(--border); border-radius:12px; padding:12px; margin-top:12px; background:#0b162b; }
  .grid { display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; }
  table { width:100%; border-collapse:collapse; }
  th, td { border-bottom:1px solid var(--border); padding:6px; text-align:left; }
  .mono { font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .subtle { color:var(--muted); }
  .pill { display:inline-block; background:#0f223e; border:1px solid var(--border); padding:2px 8px; border-radius:999px; margin-right:6px; }
  .tag { display:inline-block; border:1px solid var(--border); border-radius:6px; padding:0 6px; margin-left:6px; }
  input[type="number"] { width:80px; background:#0b1426; color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:4px; }
  input[type="file"] { color:var(--fg); }
  pre { margin:0; }
  .error { color:#ff8e8e; }
</style>
</head>
<body>
  <h1>BUILD‑V12 — Vacancy‑first then Seniority Cascade</h1>
  <div class="toolbar">
    <button id="runBtn">Run (Vacancy‑first → Cascade)</button>
    <button id="resetBtn" class="secondary">Reset Δ</button>
    <button id="reloadBtn" class="secondary">Reload JSON</button>
    <label class="subtle mono"><input type="checkbox" id="muteLedger"> Mute ledger</label>
    <label class="subtle mono"><input type="checkbox" id="muteOpen"> Mute open box</label>
    <span id="status" class="subtle mono" style="margin-left:10px"></span>
    <div class="subtle mono" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-left:auto">
      <span>Quick Adds (CA):</span>
      <label>SEA +<input id="quickSEA" type="number" value="0"></label>
      <label>ANC +<input id="quickANC" type="number" value="0"></label>
      <label>PDX +<input id="quickPDX" type="number" value="0"></label>
      <button class="secondary" id="applyQuick">Apply</button>
    </div>
  </div>

  <div class="card">
    <h3>Pilot Trace</h3>
    <div class="subtle" style="margin-bottom:6px">Type a pilot <b>Name</b> or <b>SEN</b> and run. I will log every preference check and the reason it was accepted or rejected.</div>
    <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
      <input id="traceQuery" placeholder="e.g., ERIK BACON or 1006" style="width:260px;padding:8px;border-radius:8px;border:1px solid var(--border);background:#0b1426;color:#eaf2ff">
      <label class="subtle mono"><input type="checkbox" id="traceEnabled"> Enable trace</label>
      <button class="secondary" id="traceClear">Clear log</button>
    </div>
    <pre id="traceLog" class="mono" style="white-space:pre-wrap;background:#0f182a;border:1px solid var(--border);padding:8px;border-radius:8px;max-height:260px;overflow:auto;margin-top:8px"></pre>
  </div>

  <div class="card">
    <h3>Load Data (Self‑Contained)</h3>
    <div class="subtle">Upload your three JSON files. This page never fetches from the network, so it works on GitHub Pages without CORS/path issues.</div>
    <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-top:8px">
      <label>roster.json <input type="file" id="fileRoster" accept="application/json"></label>
      <label>preferences.json <input type="file" id="filePrefs" accept="application/json"></label>
      <label>capacities.json <input type="file" id="fileCaps" accept="application/json"></label>
      <button class="secondary" id="btnUseSamples">Use sample data</button>
    </div>
    <div id="loadErr" class="error mono" style="margin-top:6px"></div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Open Vacancies</h3>
      <div id="capTable"></div>
    </div>
    <div class="card">
      <h3>Vacancy Ledger</h3>
      <div style="max-height:260px;overflow:auto">
        <table style="width:100%">
          <thead>
            <tr class="subtle">
              <th>Pass</th><th>Action</th><th>Pilot</th><th>From</th><th>To</th>
            </tr>
          </thead>
          <tbody id="ledgerBody"></tbody>
        </table>
      </div>
    </div>
    <div class="card">
      <h3>Names (Seniority)</h3>
      <div id="namesBySen" style="max-height:260px;overflow:auto"></div>
    </div>
  </div>

  <div class="card">
    <h3>Moved — Seniority Order</h3>
    <div id="movedSenList"></div>
    <div style="margin-top:8px">
      <a id="exportMovedSenCsv" class="link" href="#" download="moved_by_seniority.csv">Export moved-by-seniority CSV</a>
    </div>
  </div>

  <div class="card">
    <h3>Moves</h3>
    <div id="movesHeader" style="margin-bottom:6px"></div>
    <div id="results"></div>
  </div>

<script>
  // --- util ---
  const key = (b,s)=>`${b}__${s}`;
  const $status = { set: (s)=>document.getElementById('status').textContent = s };
  const $ledger = document.getElementById('ledgerBody');
  const $movesHdr = document.getElementById('movesHeader');
  const $results = document.getElementById('results');
  const capMap = new Map(); // k -> {base, seat, start, delta}
  const state = { running:false, pass:0, moves:[], maxPass:5000, maxMoves:100000 };
  const Occupants = new Map();
  const ineligible = new Set();

  // --- file loaders ---
  let roster = [];
  let prefs = {};

  function readFileAsJSON(file){
    return new Promise((resolve,reject)=>{
      const r = new FileReader();
      r.onload = ()=>{
        try { resolve(JSON.parse(r.result)); }
        catch(e){ reject(e); }
      };
      r.onerror = reject;
      r.readAsText(file);
    });
  }

  function useSamples(){
    // minimal plausible samples
    roster = [
      { sen: 1006, id:"1006", name:"ERIK BACON", current:{base:"LAX", seat:"CA"} },
      { sen: 1100, id:"1100", name:"JASON SMITH", current:{base:"SEA", seat:"FO"} },
    ];
    prefs = {
      "1006": { preferences: [{order:0, base:"SEA", seat:"CA"}] },
      "1100": { preferences: [{order:0, base:"SEA", seat:"CA"}] }
    };
    capMap.set(key("SEA","CA"), {base:"SEA", seat:"CA", start:100, delta:2});
    capMap.set(key("ANC","CA"), {base:"ANC", seat:"CA", start:50, delta:0});
    capMap.set(key("PDX","CA"), {base:"PDX", seat:"CA", start:40, delta:0});
    renderCapTable();
    $status.set("Loaded sample data.");
  }

  document.getElementById('btnUseSamples').onclick = useSamples;

  async function loadFromInputs(){
    const err = document.getElementById('loadErr'); err.textContent = "";
    try{
      const fR = document.getElementById('fileRoster').files[0];
      const fP = document.getElementById('filePrefs').files[0];
      const fC = document.getElementById('fileCaps').files[0];
      if(!fR || !fP || !fC) throw new Error("Select all three files first.");
      roster = await readFileAsJSON(fR);
      const pr = await readFileAsJSON(fP);
      prefs = pr;
      const caps = await readFileAsJSON(fC);
      capMap.clear();
      for(const c of caps){
        capMap.set(key(c.base, c.seat), { base:c.base, seat:c.seat, start:c.start||0, delta:c.delta||0 });
      }
      renderCapTable();
      $status.set("JSON loaded from uploads.");
    }catch(e){
      err.textContent = "Load error: " + e.message;
    }
  }

  document.getElementById('reloadBtn').onclick = loadFromInputs;

  // --- vacancy table ---
  function groupByBase(){
    const bases = {};
    for(const [k,v] of capMap.entries()){
      (bases[v.base] ||= []).push(v.seat);
    }
    for(const b of Object.keys(bases)){
      bases[b] = Array.from(new Set(bases[b])).sort((a,b)=>a===b?0 : a==='CA'?-1:b==='CA'?1:a.localeCompare(b));
    }
    return Object.keys(bases).sort().map(b=>({ base:b, seats:bases[b] }));
  }
  function renderCapTable(){
    const groups = groupByBase();
    let html = '<table><thead><tr><th>Base</th><th>Seat</th><th>Start</th><th>Δ</th><th>Adjusted</th></tr></thead><tbody>';
    for(const g of groups){
      const rowSpan = g.seats.length;
      g.seats.forEach((seat, idx)=>{
        const c = capMap.get(key(g.base, seat));
        const adj = (c?.start||0) + (c?.delta||0);
        html += '<tr>';
        if(idx===0){ html += `<td class="basehdr" rowspan="${rowSpan}">${g.base}</td>`; }
        html += `<td>${seat}</td>`;
        html += `<td><input type="number" value="${c?.start||0}" oninput="onStart('${g.base}','${seat}', this.value)"></td>`;
        html += `<td><input type="number" value="${c?.delta||0}" oninput="onDelta('${g.base}','${seat}', this.value)"></td>`;
        html += `<td class="mono">${adj}</td>`;
        html += '</tr>';
      });
    }
    html += '</tbody></table>';
    document.getElementById('capTable').innerHTML = html;
  }
  window.onStart = (b,s,v)=>{ const k=key(b,s); const c=capMap.get(k)||{base:b,seat:s,start:0,delta:0}; c.start=parseInt(v||'0',10)||0; capMap.set(k,c); renderCapTable(); };
  window.onDelta = (b,s,v)=>{ const k=key(b,s); const c=capMap.get(k)||{base:b,seat:s,start:0,delta:0}; c.delta=parseInt(v||'0',10)||0; capMap.set(k,c); renderCapTable(); };

  // --- trace helpers ---
  function qNorm(s){ return String(s||'').trim().toUpperCase(); }
  function pilotMatchesTrace(p){
    const on = (document.getElementById('traceEnabled')||{}).checked;
    if(!on) return false;
    const q = qNorm((document.getElementById('traceQuery')||{}).value||'');
    if(!q) return false;
    if (q === String(p.sen).toUpperCase()) return true;
    if (q === qNorm(p.name)) return true;
    return false;
  }
  function logTrace(msg){
    const box = document.getElementById('traceLog');
    if(!box) return;
    box.textContent += (box.textContent ? '\n' : '') + msg;
    box.scrollTop = box.scrollHeight;
  }
  function clearTrace(){ const box=document.getElementById('traceLog'); if(box) box.textContent=''; }
  document.getElementById('traceClear').onclick = clearTrace;

  // --- eligibility ---
  function isEligiblePilot(p){ return !ineligible.has(String(p.id||p.sen)); }

  // --- dynamic occupants for BPL ---
  function seedOccupants(){
    Occupants.clear();
    for(const p of roster){
      const k = key(p.current.base, p.current.seat);
      if(!Occupants.has(k)) Occupants.set(k, new Set());
      Occupants.get(k).add(p.sen);
    }
  }
  function moveOccupant(p, fromK, toK){
    if(fromK){ const s = Occupants.get(fromK); if(s) s.delete(p.sen); }
    if(!Occupants.has(toK)) Occupants.set(toK, new Set());
    Occupants.get(toK).add(p.sen);
  }
  function pilotRankIfMoved(p, toK){
    const occSet = new Set(Occupants.get(toK) || []);
    occSet.add(p.sen);
    const occ = Array.from(occSet).sort((a,b)=>a-b);
    const rank = occ.indexOf(p.sen) + 1;
    const total = occ.length;
    const percentile = (rank / total) * 100.0;
    return { rank, total, percentile };
  }
  function extractBPL(w){
    const hasExplicitNoBpl = Number(w.bpl_min) === 0;
    if (hasExplicitNoBpl) return {};
    function toPos(n){ const x=Number(n); return Number.isFinite(x)&&x>0?x:null; }
    const out = {};
    const r = toPos(w.bpl_rank_lte);
    const t = toPos(w.bpl_top_n);
    const p = toPos(w.bpl_percentile_lte);
    if (r!=null) out.rank_lte = r;
    if (t!=null) out.top_n = t;
    if (p!=null) out.pct_lte = p;
    if (!out.rank_lte && !out.top_n && !out.pct_lte){
      const txt = String(w.note || w.comment || w.label || '').toUpperCase();
      const m1 = txt.match(/BPL[^0-9]*([0-9]{1,4})/);
      const m2 = txt.match(/TOP[^0-9]*([0-9]{1,4})/);
      const r2 = m1 ? toPos(m1[1]) : null;
      const t2 = m2 ? toPos(m2[1]) : null;
      if (r2!=null) out.rank_lte = r2;
      if (t2!=null) out.top_n   = t2;
    }
    return out;
  }
  function bplSatisfied(p, w, toK){
    const bpl = extractBPL(w);
    if (!bpl || (!bpl.rank_lte && !bpl.top_n && !bpl.pct_lte)) return { ok:true, reason:null };
    const r = pilotRankIfMoved(p, toK);
    if (bpl.rank_lte!=null && !(r.rank <= bpl.rank_lte)) return { ok:false, reason:`rank ${r.rank} > ${bpl.rank_lte}` };
    if (bpl.top_n!=null   && !(r.rank <= bpl.top_n))     return { ok:false, reason:`rank ${r.rank} > top ${bpl.top_n}` };
    if (bpl.pct_lte!=null && !(r.percentile <= bpl.pct_lte)) return { ok:false, reason:`percentile ${r.percentile.toFixed(1)} > ${bpl.pct_lte}` };
    return { ok:true, reason:null };
  }

  // --- preferences helpers ---
  function nSeat(x){
    const t = String(x||'').trim().toUpperCase();
    if (!t) return null;
    if (t==='FO' || /FIRST[\s\-_]*OFFICER/.test(t) || /F\/?O/.test(t) || /CO[\s\-_]*PILOT/.test(t)) return 'FO';
    if (t==='CA' || t==='CPT' || /CAPT(AIN)?/.test(t)) return 'CA';
    return t;
  }
  function sameChoice(db, ds, cb, cs){
    const dsN = nSeat(ds);
    if (String(db||'').toUpperCase() !== String(cb||'').toUpperCase()) return false;
    if (dsN===null) return true;
    return dsN === String(cs||'').toUpperCase();
  }
  function firstBidSaysStay(p){
    const all = (prefs[p.id]?.preferences || []).slice();
    all.sort((a,b)=>((a?.order ?? 1e9) - (b?.order ?? 1e9)));
    const first = all[0];
    if (!first) return false;
    if (first.stay === true) return true;
    return sameChoice(first.base, first.seat, p.current.base, p.current.seat);
  }
  function rankPrefs(p){
    const list=(prefs[p.id]?.preferences||[]).slice().filter(x=>x && x.stay!==true);
    list.sort((a,b)=>(a.order||0)-(b.order||0));
    return list;
  }

  // --- rendering movers ---
  function renderLists(){
    const upgrades = [...state.moves.filter(m=>m.move_type==='upgrade')].sort((a,b)=> (a.sen||1e9)-(b.sen||1e9));
    const laterals = [...state.moves.filter(m=>m.move_type==='lateral')].sort((a,b)=> (a.sen||1e9)-(b.sen||1e9));
    $movesHdr.innerHTML = `<span class="pill">Passes: ${state.pass}</span><span class="pill">Moves: ${state.moves.length}</span><span class="pill">Upgrades: ${upgrades.length}</span><span class="pill">Laterals: ${laterals.length}</span>`;
    function rowLine(m){
      const name = m.name ? ` ${m.name}` : '';
      return `${m.sen}${name}: ${m.fromB} ${m.fromS} → <b>${m.toB} ${m.toS}</b>`;
    }
    let html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">';
    html += '<div><div class="subtle" style="margin-bottom:6px">Upgrades</div><ol>';
    for(const m of upgrades){ html += `<li>${rowLine(m)} <span class="tag up">[Upgrade]</span>${m.bpl?' <span class="tag">[BPL]</span>':''}</li>`; }
    html += '</ol></div>';
    html += '<div><div class="subtle" style="margin-bottom:6px">Laterals</div><ol>';
    for(const m of laterals){ html += `<li>${rowLine(m)} <span class="tag lat">[Lateral]</span>${m.bpl?' <span class="tag">[BPL]</span>':''}</li>`; }
    html += '</ol></div>';
    html += '</div>';
    $results.innerHTML = html;

    const movedBySen = [...state.moves].sort((a,b)=> (a.sen||1e9)-(b.sen||1e9));
    let shtml = '<ol class="mono">';
    for(const m of movedBySen){
      const name = m.name ? ' '+m.name : '';
      const tag = m.move_type==='upgrade' ? '<span class="tag up">[Upgrade]</span>' : '<span class="tag lat">[Lateral]</span>';
      const bpl = m.bpl ? ' <span class="tag">[BPL]</span>' : '';
      shtml += `<li>${m.sen}${name} — ${m.fromB} ${m.fromS} → <b>${m.toB} ${m.toS}</b> ${tag}${bpl}</li>`;
    }
    shtml += '</ol>';
    const slotA = document.getElementById('movedSenList'); if (slotA) slotA.innerHTML = shtml;
    const slotB = document.getElementById('namesBySen'); if (slotB) slotB.innerHTML = shtml;

    // CSV
    const esc = v => '"' + String(v==null?'':v).replaceAll('"','""') + '"';
    const header = ['sen','id','name','from_base','from_seat','to_base','to_seat','move_type','bpl'];
    const body = movedBySen.map(r=>[r.sen,r.id||'',r.name||'',r.fromB,r.fromS,r.toB,r.toS,r.move_type, r.bpl?1:0].map(esc).join(','));
    const csv = [header.join(','), ...body].join('\n');
    const url = URL.createObjectURL(new Blob([csv], {type:'text/csv'}));
    const link = document.getElementById('exportMovedSenCsv'); if (link) link.href = url;
  }

  // --- run core ---
  function seedIncumbents(){ const m=new Map(); for(const p of roster){ const k=key(p.current.base,p.current.seat); m.set(k,(m.get(k)||0)+1); } return m; }
  function renderOpenBatched(batch){ if(document.getElementById('muteOpen').checked) return; /* omitted for brevity */ }
  function renderLedgerBatched(batch){
    if(document.getElementById('muteLedger').checked) return;
    let rows='';
    for(const rec of batch){ rows += `<tr><td class="mono">${rec.pass}</td><td>${rec.action}</td><td class="mono">${rec.sen} ${rec.name||''}</td><td class="mono">${rec.from||''}</td><td class="mono">${rec.to||''}</td></tr>`; }
    $ledger.insertAdjacentHTML('beforeend', rows);
  }

  function tryAward(p, fromK, toK, batchOpen, batchLedger, markBPL){
    const [tb, ts] = toK.split('__');
    // consume
    batchOpen.set(toK, (batchOpen.get(toK)||0)-1);
    batchOpen.set(fromK, (batchOpen.get(fromK)||0)+1);
    const was = { base: p.current.base, seat: p.current.seat };
    moveOccupant(p, fromK, toK);
    p.current = { base: tb, seat: ts };
    const mtype = (was.seat==='FO' && ts==='CA') ? 'upgrade' : 'lateral';
    state.moves.push({ sen: p.sen, id: p.id||'', name: p.name||'', fromB: was.base, fromS: was.seat, toB: tb, toS: ts, move_type: mtype, bpl: !!markBPL });
    batchLedger.push({ pass: state.pass, action:'AWARD', sen:p.sen, name:p.name||'', from:`${was.base} ${was.seat}`, to:`${tb} ${ts}` });
    return true;
  }

  function run(){
    $status.set("Running…");
    state.running = true; state.pass = 0; state.moves = [];
    $ledger.innerHTML='';
    seedOccupants();
    const adjusted = new Map(); for(const [k,v] of capMap.entries()){ adjusted.set(k, (v.start||0)+(v.delta||0)); }
    const incumb = seedIncumbents();
    const Open = new Map(); for(const [k,adj] of adjusted.entries()){ Open.set(k, adj - (incumb.get(k)||0)); }

    const sorted = roster.slice().filter(isEligiblePilot).sort((a,b)=>a.sen-b.sen);
    const moved = new Set();
    let changed = true;
    while(changed && state.pass < state.maxPass && state.moves.length < state.maxMoves){
      changed = false; state.pass += 1;
      const batchOpen = new Map(); const batchLedger = [];
      // posted CA adds first (vacancy-first)
      for(const p of sorted){
        if (moved.has(p.id||p.sen)) continue;
        if (firstBidSaysStay(p)) continue;
        const wants = rankPrefs(p);
        if(!wants.length) continue;
        // consider only CA targets for vacancy pass
        const fromK = key(p.current.base, p.current.seat);
        const want = wants[0]; // first preference governs vacancy pass
        if (want.seat !== 'CA') continue;
        const toK = key(want.base, 'CA');
        const eff = (Open.get(toK)||0) + (batchOpen.get(toK)||0);
        if (pilotMatchesTrace(p)) logTrace(`[PASS ${state.pass}] Considering ${p.sen} ${p.name} for ${want.base} CA (effOpen=${eff})`);
        if (eff <= 0){ if (pilotMatchesTrace(p)) logTrace(`  REJECT: no effective open at ${want.base} CA`); continue; }
        const bplCheck = bplSatisfied(p, want, toK);
        if (!bplCheck.ok){ if (pilotMatchesTrace(p)) logTrace(`  REJECT: BPL fail (${bplCheck.reason})`); continue; }
        if (tryAward(p, fromK, toK, batchOpen, batchLedger, /*bpl*/true)){
          moved.add(p.id||p.sen); changed = true;
        }
      }
      renderOpenBatched(batchOpen); renderLedgerBatched(batchLedger); renderLists();

      // cascade
      const batchOpen2 = new Map(); const batchLedger2 = [];
      for(const p of sorted){
        if (moved.has(p.id||p.sen)) continue;
        if (firstBidSaysStay(p)) continue;
        const fromK = key(p.current.base, p.current.seat);
        const prefsRanked = rankPrefs(p);
        for(const w of prefsRanked){
          if (sameChoice(w.base, w.seat, p.current.base, p.current.seat)){ if (pilotMatchesTrace(p)) logTrace(`[PASS ${state.pass}] HIT STAY: ${w.base||p.current.base} ${w.seat||p.current.seat}`); moved.add(p.id||p.sen); break; }
          const toK = key(w.base, w.seat);
          const eff = (Open.get(toK)||0) + (batchOpen2.get(toK)||0);
          if (pilotMatchesTrace(p)) logTrace(`[PASS ${state.pass}] Pref ${w.base} ${w.seat} (effOpen=${eff}) for ${p.sen} ${p.name}`);
          if (eff <= 0){ if (pilotMatchesTrace(p)) logTrace(`  REJECT: no effective open at ${w.base} ${w.seat}`); continue; }
          const bplCheck = bplSatisfied(p, w, toK);
          if (!bplCheck.ok){ if (pilotMatchesTrace(p)) logTrace(`  REJECT: BPL fail (${bplCheck.reason}) for ${w.base} ${w.seat}`); continue; }
          if (tryAward(p, fromK, toK, batchOpen2, batchLedger2, /*bpl*/true)){ moved.add(p.id||p.sen); changed = true; break; }
        }
      }
      renderOpenBatched(batchOpen2); renderLedgerBatched(batchLedger2); renderLists();

      // commit batch opens
      for(const [k,v] of batchOpen){ Open.set(k, (Open.get(k)||0)+v); }
      for(const [k,v] of batchOpen2){ Open.set(k, (Open.get(k)||0)+v); }
    }

    renderLists();
    state.running = false;
    $status.set("Simulation complete.");
  }

  document.getElementById('runBtn').onclick = run;
  document.getElementById('resetBtn').onclick = ()=>{ for(const [k,c] of capMap.entries()){ c.delta = 0; capMap.set(k,c); } renderCapTable(); $status.set("Δ reset."); };
  document.getElementById('applyQuick').onclick = ()=>{
    const s = parseInt(document.getElementById('quickSEA').value||'0',10)||0;
    const a = parseInt(document.getElementById('quickANC').value||'0',10)||0;
    const p = parseInt(document.getElementById('quickPDX').value||'0',10)||0;
    const setD = (b,v)=>{ const k=key(b,'CA'); const c=capMap.get(k)||{base:b,seat:'CA',start:0,delta:0}; c.delta=v; capMap.set(k,c); };
    setD('SEA', s); setD('ANC', a); setD('PDX', p); renderCapTable();
  };
</script>
</body>
</html>
