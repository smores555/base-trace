<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Base Trace — Vacancy · Restart · Improve-only · BPL · Paper</title>
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
<link rel="icon" href="favicon.ico">
</head>
<body>
<h1>Base Trace</h1>
<button id="runBtn">Run</button>
<button id="resetDeltaBtn">Delta Reset</button>
<button id="reloadBtn">Reload</button>
<pre id="trace"></pre>

<script>
/* --- core helpers --- */
const key = (b,s)=>`${b.trim().toUpperCase()}_${s.trim().toUpperCase()}`;
const sameChoice=(b1,s1,b2,s2)=>b1.toUpperCase()===b2.toUpperCase() && s1.toUpperCase()===s2.toUpperCase();
function pilotMatchesTrace(p){ return true; } // stub for your trace filter
function logTrace(msg){ document.getElementById('trace').textContent += msg + '\n'; }

/* dummy placeholders: your real app already defines these elsewhere */
function vacAmt(k){ return capMap.get(k)?.delta ?? 0; }
function vacDec(k,n){ const c=capMap.get(k); if(c) c.delta-=n; }
function vacInc(k,n){ const c=capMap.get(k); if(c) c.delta+=n; }
function renderLedgerRows(){};
function renderOpen(){};
function renderNamesBySeniority(){};
function award(){};
function bplSatisfied(){ return {ok:true,reason:""}; }
function isPaper(){ return false; }
function rankPrefs(p){ return p.preferences||[]; }
function prefRank(p,b,s){ return 0; }
function prefEntryFor(p){ return p; }

/* --- placeholders for runtime state --- */
let capMap=new Map();
let sorted=[];
let pinned=new Set();
let bestRank=new Map();
let state={pass:0,moves:[]};

/* --- PRE-PASS BPL LOCK FIX --- */
for (const p of sorted) {
  const pe = prefEntryFor(p);
  if (!pe) continue;

  const top = (pe.preferences || [])[0];
  const atTop =
    top &&
    String(top.base).toUpperCase() === p.current?.base &&
    String(top.seat).toUpperCase() === p.current?.seat;

  if (!atTop) continue; // only if at #1 pref
  const limit = Number(top.bpl_min ?? 0);
  if (limit <= 0) continue; // unrestricted

  const bpl = bplSatisfied(p, top, key(p.current.base, p.current.seat));
  if (bpl.ok) {
    pinned.add(p.sen);
    if (pilotMatchesTrace(p))
      logTrace(`PINNED: ${p.sen} staying ${p.current.base} ${p.current.seat} (#1 pref & BPL=${limit} met)`);
  } else {
    if (pilotMatchesTrace(p))
      logTrace(`BPL NOT MET: ${p.sen} ${p.current.base} ${p.current.seat} (#1 pref, unmet BPL=${limit})`);
  }
}

/* --- CASCADE LOOP FIX --- */
let anyMoves = true;
while (anyMoves) {
  anyMoves = false;

  // always ensure strict seniority order each sweep
  sorted.sort((a,b)=>a.sen-b.sen);

  for (const p of sorted) {
    if (pinned.has(p.sen)) continue;
    const fromK = key(p.current.base, p.current.seat);
    const list = rankPrefs(p);

    for (const w of list) {
      // stop-after-home with proper BPL restriction
      if (sameChoice(w.base,w.seat,p.current.base,p.current.seat)) {
        const pe = prefEntryFor(p);
        const topPref = pe?.preferences?.[0];
        const atTop =
          topPref &&
          String(topPref.base).toUpperCase() === p.current.base &&
          String(topPref.seat).toUpperCase() === p.current.seat;
        if (atTop && Number(topPref.bpl_min ?? 0) > 0) {
          const bpl = bplSatisfied(p, topPref, key(w.base, w.seat));
          if (bpl.ok) {
            pinned.add(p.sen);
            if (pilotMatchesTrace(p))
              logTrace(`PINNED: ${p.sen} staying ${w.base} ${w.seat} (#1 pref & BPL met)`);
            break;
          } else {
            if (pilotMatchesTrace(p))
              logTrace(`BPL not met (${bpl.reason}) → continuing search`);
            continue;
          }
        }
        break; // not top or unrestricted → skip pinning
      }

      const toK = key(w.base, w.seat);
      const have = vacAmt(toK);
      if (pilotMatchesTrace(p))
        logTrace(`[PASS ${state.pass}] Pref ${w.base} ${w.seat} (Vac=${have}) for ${p.sen}`);
      if (have <= 0) { if (pilotMatchesTrace(p)) logTrace('  REJECT: no vacancy'); continue; }

      const rNow = bestRank.get(p.sen) ?? Infinity;
      const rWish = prefRank(p, w.base, w.seat);
      if (rWish >= rNow && w.base === p.current.base) continue;

      const bpl = bplSatisfied(p, w, toK);
      if (!bpl.ok) { if (pilotMatchesTrace(p)) logTrace('  REJECT: BPL'); continue; }

      // award
      state.pass++;
      const rows=[];
      award(p, fromK, toK, 'cascade', rows);
      if (!isPaper(p)) { vacDec(toK,1); vacInc(fromK,1); }
      renderLedgerRows(rows); renderOpen(); renderNamesBySeniority();

      anyMoves = true; // restart from top
      break;
    }
  }
}

state.running = false;
document.getElementById('trace').textContent +=
  `\nSimulation complete. Passes=${state.pass}`;
</script>
</body>
</html>
